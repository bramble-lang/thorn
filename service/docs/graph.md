# Graphs
Here lies the details for how graph structures are generated from the current
trace data format.

## Relevant Trace Data Schema Details
For our purposes, the trace event schema contains three fields that are relevant
for graph topology.

The first field is the `stage` field, this groups related
events together and, at present, events in different stages cannot be linked
together.

The second field is the `source` field.  This is a span of source code from which
this event is directly derived. In other words, the span identifies the string
in the source code that caused this event to happen.

The third field is the `ref` field. This is a span that links to contextual or
"referenced" source code that was referenced by the compiler in order to make the
decision described in the event.  This is _not_ used by the lexer or parser which
are context free grammars. An example of a `ref` span is when resolving the type
of an expression that contains a function call, the type resolver needs the type
that the function returns in order to determine what the expression type is and so
it must "refer" to the function definition. In this example, the `ref` span would
cover the definition of the called function.

The other fields of the event cover descriptive details for the event and are
not related to topology and, therefore, are not relevant to graph construction.

## Assumptions
These are assumptions made about the trace data. These assumptions may change with
time or they may lead to being codified directly into the trace event schema
in some way.

1. The order in the trace data file is the order that the events were logically
generated.

## Definitions
1. `span`: is a range `[a,b) in [0...)` and it marks a subset of the source code.
 The `low` value of the `span` is `a` and marks the start of the first element in the source
 code subset.  The `high` value of the span is `b` and it marks the start of
 the first element _after_ the subset of source code.
1. `inf(span)`: is the `low` element of the span. (cf. infimum)
1. `sup(span)`: is the `high` element of the span.  (cf. suprema)
1. A span `S` is a subset of a span `T` if and only if:
    - `inf(T) <= inf(S)`
    - `sup(S) <= sup(T)`
1. An event, `E`, is a subevent of an event `F` if and only if
    - `E` and `F` have the same stage
    - The span of `E` is a subset of the span of `F`
1. An event `E` precedes an event `F` if and only if
    - `E` and `F` have the same stage
    - `E` appears in the trace sequence after `F`.  This is a result of the AST
    being traversed in post-order.
    - `F` is a subset of `E`
1. An event `E` is the _parent_ of an event `F` if and only if
    - `E` precedes `F`
    - There does not exist an event `G` (not equal to `E` or `F`) that follows `E` and precedes `F`.
    - In other words, there is no event which occurs between `E` and `F`

## Graph Construction Overview
### Why
The definitions above describe how the current trace event schema implies
the topology of the event graph. What we want to do is turn that implicit
topology into an explicit topology, because that will make it easy to
graph/tree based visualizations.

### Algorithm
Group the trace events into subsequences by the `stage`, while maintaining
the ordering from the source file.

To construct the graph for some `stage`, take the associated subsequence.
Call this sequence `T`.  `len(T)` is the number of elements in `T` and 
`T[i]` is the is the `i`th element in `T`.

This algorithm will start at the end of `T` and move toward the start. For
each event, it will find (if it exists) the parent of that event. If no
parent is found, then it will be marked as a root node (there may be multiple
root nodes in a graph).  The parent is the first event found which contains
the current event (this is dependent upon the assumptions above).

1. For `i` from `len(T)-1` to `0`
    1. For `j` from `i-1` to `0`
        1. If `T[i]` is a subset of `T[j]` then `T[j]` is the parent

This is a `O(n^2)` algorithm.  It is not efficient, but for a few thousand events it will be sufficient.  If more performance is needed, then the 
correct solution will be to better encode topology into the event schema.

This is dependent upon the current implementation and behavior of `bramblec`.
Specifically, that all analysis stages follow the partial order imposed by
the AST generated by the parser _and_ that the parser is serial and there
is no concurrency. And that events are written to the file sequentially
and synchronously. In other words, the events that are written to the file
are in the exact order of their evaluation by the compiler.

In other words, if `E` is the parent of `F`, then there will be no events
in the trace file between `E` and `F` whose spans contain `F`. There may
be other events between `E` and `F` but they will _not_ have spans that
contain the span of `F`.  They _will_ be descendants of `E`.

### Implementation Details
This will use the `petgraph` library to handle storing the actual
representation of the graph as it is constructed. This library was
chosen because it supports `graphviz` and it still seems to be 
actively maintained (there were other Rust libraries that support
`graphviz` but they are less active or dead).  `graphviz` support
is a minimum requirement because the purpose of this is to provide
a graph definition to the web UI for visualization and using the DOT
format means using a standard with a lot of supporting tools.

The purpose of the graph library, at this time, is solely to handle
generating the DOT representation of the graph.